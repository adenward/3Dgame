<html>
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
  <title>3D Game Design</title>
  <script src="cannon.js"></script>
  <script src="babylon.js"></script>
  <script src="babylon.objFileLoader.min.js"></script>
  <style>
    html, body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #timer {
position: absolute;
left:10px;
bottom:10px;
color:#ccc;
font: 52px sans-serif;
} 

  </style>
  <script>
    function start() {
      var canvas = document.getElementById('renderCanvas');
      
      var engine = new BABYLON.Engine(canvas, true);

      var keys = {};
      window.addEventListener('keydown', function(e) {
        keys[e.key] = true;
      });
      window.addEventListener('keyup', function(e) {
        keys[e.key] = false;
      });

      var scene = new BABYLON.Scene(engine);

      var gravityVector = new BABYLON.Vector3(0, -9.81, 0);
      scene.enablePhysics(gravityVector, new BABYLON.CannonJSPlugin());

      scene.clearColor = new BABYLON.Color3(0, 0, 0);
      
      scene.clearColor = new BABYLON.Color3.Black();      

      //===TRACK CODE
var _xFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.025)+(3*t*Math.pow((1-t),2)*0.1)+(3*Math.pow(t,2)*(1-t)*0.185)+(Math.pow(t,3)*0.215)},function(t) {return (Math.pow((1-t),3)*0.215)+(3*t*Math.pow((1-t),2)*0.245)+(3*Math.pow(t,2)*(1-t)*0.3825)+(Math.pow(t,3)*0.3825)},function(t) {return (Math.pow((1-t),3)*0.3825)+(3*t*Math.pow((1-t),2)*0.3825)+(3*Math.pow(t,2)*(1-t)*0.1325)+(Math.pow(t,3)*0.1325)},function(t) {return (Math.pow((1-t),3)*0.1325)+(3*t*Math.pow((1-t),2)*0.1325)+(3*Math.pow(t,2)*(1-t)*0.3)+(Math.pow(t,3)*0.3)},function(t) {return (Math.pow((1-t),3)*0.3)+(3*t*Math.pow((1-t),2)*0.3)+(3*Math.pow(t,2)*(1-t)*0.3875)+(Math.pow(t,3)*0.3875)},function(t) {return (Math.pow((1-t),3)*0.3875)+(3*t*Math.pow((1-t),2)*0.3875)+(3*Math.pow(t,2)*(1-t)*0.0475)+(Math.pow(t,3)*0.1025)},function(t) {return (Math.pow((1-t),3)*0.1025)+(3*t*Math.pow((1-t),2)*0.1575)+(3*Math.pow(t,2)*(1-t)*0.345)+(Math.pow(t,3)*0.345)},function(t) {return (Math.pow((1-t),3)*0.345)+(3*t*Math.pow((1-t),2)*0.345)+(3*Math.pow(t,2)*(1-t)*0.7575)+(Math.pow(t,3)*0.7575)},function(t) {return (Math.pow((1-t),3)*0.7575)+(3*t*Math.pow((1-t),2)*0.7575)+(3*Math.pow(t,2)*(1-t)*0.66)+(Math.pow(t,3)*0.66)},function(t) {return (Math.pow((1-t),3)*0.66)+(3*t*Math.pow((1-t),2)*0.66)+(3*Math.pow(t,2)*(1-t)*0.9575)+(Math.pow(t,3)*0.9575)},function(t) {return (Math.pow((1-t),3)*0.9575)+(3*t*Math.pow((1-t),2)*0.9575)+(3*Math.pow(t,2)*(1-t)*0.61)+(Math.pow(t,3)*0.61)},function(t) {return (Math.pow((1-t),3)*0.61)+(3*t*Math.pow((1-t),2)*0.61)+(3*Math.pow(t,2)*(1-t)*0.6)+(Math.pow(t,3)*0.6)},function(t) {return (Math.pow((1-t),3)*0.6)+(3*t*Math.pow((1-t),2)*0.6)+(3*Math.pow(t,2)*(1-t)*0.9425)+(Math.pow(t,3)*0.9425)},function(t) {return (Math.pow((1-t),3)*0.9425)+(3*t*Math.pow((1-t),2)*0.9425)+(3*Math.pow(t,2)*(1-t)*0.54)+(Math.pow(t,3)*0.54)},function(t) {return (Math.pow((1-t),3)*0.54)+(3*t*Math.pow((1-t),2)*0.54)+(3*Math.pow(t,2)*(1-t)*0.5075)+(Math.pow(t,3)*0.5075)},function(t) {return (Math.pow((1-t),3)*0.5075)+(3*t*Math.pow((1-t),2)*0.5075)+(3*Math.pow(t,2)*(1-t)*0.955)+(Math.pow(t,3)*0.955)}];var i = Math.max(0,Math.min(15, Math.floor(t * 16)));return fns[i]((t - (i/16)) * 16);};
var _yFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.2)+(3*t*Math.pow((1-t),2)*0.025)+(3*Math.pow(t,2)*(1-t)*0.4128125)+(Math.pow(t,3)*0.1303125)},function(t) {return (Math.pow((1-t),3)*0.1303125)+(3*t*Math.pow((1-t),2)*-0.1521875)+(3*Math.pow(t,2)*(1-t)*0.1453125)+(Math.pow(t,3)*0.1453125)},function(t) {return (Math.pow((1-t),3)*0.1453125)+(3*t*Math.pow((1-t),2)*0.1453125)+(3*Math.pow(t,2)*(1-t)*0.3528125)+(Math.pow(t,3)*0.3528125)},function(t) {return (Math.pow((1-t),3)*0.3528125)+(3*t*Math.pow((1-t),2)*0.3528125)+(3*Math.pow(t,2)*(1-t)*0.7878125)+(Math.pow(t,3)*0.7878125)},function(t) {return (Math.pow((1-t),3)*0.7878125)+(3*t*Math.pow((1-t),2)*0.7878125)+(3*Math.pow(t,2)*(1-t)*0.6478125)+(Math.pow(t,3)*0.6478125)},function(t) {return (Math.pow((1-t),3)*0.6478125)+(3*t*Math.pow((1-t),2)*0.6478125)+(3*Math.pow(t,2)*(1-t)*0.7703125)+(Math.pow(t,3)*0.2478125)},function(t) {return (Math.pow((1-t),3)*0.2478125)+(3*t*Math.pow((1-t),2)*-0.2746875)+(3*Math.pow(t,2)*(1-t)*0.3603125)+(Math.pow(t,3)*0.3603125)},function(t) {return (Math.pow((1-t),3)*0.3603125)+(3*t*Math.pow((1-t),2)*0.3603125)+(3*Math.pow(t,2)*(1-t)*0.3503125)+(Math.pow(t,3)*0.3503125)},function(t) {return (Math.pow((1-t),3)*0.3503125)+(3*t*Math.pow((1-t),2)*0.3503125)+(3*Math.pow(t,2)*(1-t)*0.9253125)+(Math.pow(t,3)*0.9253125)},function(t) {return (Math.pow((1-t),3)*0.9253125)+(3*t*Math.pow((1-t),2)*0.9253125)+(3*Math.pow(t,2)*(1-t)*0.6728125)+(Math.pow(t,3)*0.6728125)},function(t) {return (Math.pow((1-t),3)*0.6728125)+(3*t*Math.pow((1-t),2)*0.6728125)+(3*Math.pow(t,2)*(1-t)*0.5328125)+(Math.pow(t,3)*0.5328125)},function(t) {return (Math.pow((1-t),3)*0.5328125)+(3*t*Math.pow((1-t),2)*0.5328125)+(3*Math.pow(t,2)*(1-t)*0.1778125)+(Math.pow(t,3)*0.1778125)},function(t) {return (Math.pow((1-t),3)*0.1778125)+(3*t*Math.pow((1-t),2)*0.1778125)+(3*Math.pow(t,2)*(1-t)*0.0928125)+(Math.pow(t,3)*0.0928125)},function(t) {return (Math.pow((1-t),3)*0.0928125)+(3*t*Math.pow((1-t),2)*0.0928125)+(3*Math.pow(t,2)*(1-t)*0.0678125)+(Math.pow(t,3)*0.0678125)},function(t) {return (Math.pow((1-t),3)*0.0678125)+(3*t*Math.pow((1-t),2)*0.0678125)+(3*Math.pow(t,2)*(1-t)*0.6828125)+(Math.pow(t,3)*0.6828125)},function(t) {return (Math.pow((1-t),3)*0.6828125)+(3*t*Math.pow((1-t),2)*0.6828125)+(3*Math.pow(t,2)*(1-t)*0.9453125)+(Math.pow(t,3)*0.9453125)}];var i = Math.max(0,Math.min(15, Math.floor(t * 16)));return fns[i]((t - (i/16)) * 16);};
/* START CURVE DATA 
{"start":[10,80],"init":[40,10],"segments":[{"a":[74,165.125],"b":[86,52.125]},{"a":[153,58.125],"b":[153,58.125]},{"a":[53,141.125],"b":[53,141.125]},{"a":[120,315.125],"b":[120,315.125]},{"a":[155,259.125],"b":[155,259.125]},{"a":[19,308.125],"b":[41,99.125]},{"a":[138,144.125],"b":[138,144.125]},{"a":[303,140.125],"b":[303,140.125]},{"a":[264,370.125],"b":[264,370.125]},{"a":[383,269.125],"b":[383,269.125]},{"a":[244,213.125],"b":[244,213.125]},{"a":[240,71.125],"b":[240,71.125]},{"a":[377,37.125],"b":[377,37.125]},{"a":[216,27.125],"b":[216,27.125]},{"a":[203,273.125],"b":[203,273.125]},{"a":[382,378.125],"b":[382,378.125]}]}
   END CURVE DATA */
      //===END TRACK CODE

      var xFn = function(t) { return 650 * _xFn(t); }
      var zFn = function(t) { return 650 * _yFn(t); }

      var playerSphere = BABYLON.MeshBuilder.CreateSphere("playerSphere", {
        segments: 12,
        diameter: 4
      }, scene);
        playerSphere.material = new BABYLON.StandardMaterial("playerSphereMaterial", scene);
       playerSphere.material.diffuseTexture = new BABYLON.Texture('resources/BeachBallColor.jpg', scene);

       playerSphere.position = new BABYLON.Vector3(xFn(0), 9, zFn(0));

      playerSphere.physicsImpostor = new BABYLON.PhysicsImpostor(playerSphere, BABYLON.PhysicsImpostor.SphereImpostor, {
        mass: 1,
        restitution: 0.9
      }, scene);

      BABYLON.SceneLoader.ImportMesh(null, "resources/", "speed.obj", scene, function(meshes) {
var boostMesh = meshes[0], boosts = [];
boostMesh.material = new BABYLON.StandardMaterial("boostMaterial", scene);
boostMesh.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
boostMesh.scaling = new BABYLON.Vector3(5, 5, 5);
boostMesh.setEnabled(false);
function boostAt(xFn, zFn, t) {
var newBoost = boostMesh.clone('boost');
newBoost.position = new BABYLON.Vector3(xFn(t), 3.2, zFn(t));
newBoost.rotation.y = -derivAngle(t, xFn, zFn);
newBoost.setEnabled(true);
boosts.push(newBoost);
}

// Place boosts here
boostAt(xFn, zFn, 0.01);
boostAt(xFn, zFn, 0.95);

scene.registerAfterRender(function() {
boosts.forEach(function(boost, i){
if(boost.intersectsMesh(playerSphere)){
boost.dispose();
boosts.splice(i,1);
var vel = playerSphere.physicsImpostor.getLinearVelocity();
playerSphere.applyImpulse(vel.normalize().scale(100), playerSphere.getAbsolutePosition());
} else {
boost.rotation.y += 0.01
}
});
});
}); 

    var camera = new BABYLON.ArcRotateCamera("Camera", 0, (3 * Math.PI) / 8, 20, playerSphere, scene);

        camera.attachControl(canvas, true);

        var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);


        rampAt(xFn, zFn, 0.02, -Math.PI / 4, scene);
        rampAt(xFn, zFn, 0.03, Math.PI / 4, scene);
        rampAt(xFn, zFn, 0.06, -Math.PI / 4, scene);
 		rampAt(xFn, zFn, 0.07, Math.PI / 4, scene);
 	 	rampAt(xFn, zFn, 0.14, -Math.PI / 4, scene);
 	 	rampAt(xFn, zFn, 0.16, Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.22, -Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.23, Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.46, -Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.48, Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.02, -Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.66, -Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.67, Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.96, -Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.98, Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.47, -Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.47, Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.97,-Math.PI / 4, scene);
 	    rampAt(xFn, zFn, 0.97, Math.PI / 4, scene);

        /* OTHER rampAt Code here However many they want*/
//NEW CODE
        wallAt(xFn, zFn, 0.47,  -6.1, scene);
        wallAt(xFn, zFn, 0.47,  6.1, scene);
        wallAt(xFn, zFn, 0.47,  0.1, scene);


        var startTime;
var timer = document.querySelector('#timer'); 



       
//END NEW CODE

        scene.registerAfterRender(function() {
          var vel = playerSphere.physicsImpostor.getLinearVelocity();
          playerSphere.physicsImpostor.setLinearVelocity(vel.scale(.98));

          var forward = camera.getFrontPosition(1).subtract(camera.position);
          forward.y = 0;
          forward = forward.normalize().scale(1);
          
          var backward = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY(Math.PI));

          var left = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY((3 * Math.PI) / 2));

          var  right = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY(Math.PI / 2));

          if (keys.w) {
          if(!startTime){ startTime = Date.now(); } 

            playerSphere.applyImpulse(forward, playerSphere.getAbsolutePosition());
          }
          if (keys.s) {
            playerSphere.applyImpulse(backward, playerSphere.getAbsolutePosition());
          }
          if (keys.a) {
            playerSphere.applyImpulse(left, playerSphere.getAbsolutePosition());
          }
          if (keys.d) {
            playerSphere.applyImpulse(right, playerSphere.getAbsolutePosition());
          }

          var l = false;
          if (playerSphere.position.y < -10 && l == false) {
            l = true;
            lost();
          }

          var currentT = tLookup(xFn, zFn, 500, playerSphere.position.x, playerSphere.position.z);

          var angle = (derivAngle(currentT, xFn, zFn) - (Math.PI)); 
camera.alpha += (angle - camera.alpha) / 32; 

          if (currentT > 0.99) {
            win();
          }
      });

      function drawPoint(x, z, zrot, scene) {
        var point = BABYLON.MeshBuilder.CreateBox('point', { 
          width: 10, 
          height: 0.5, 
          depth: 12 
        }, scene);
        point.material = new BABYLON.StandardMaterial("pointMaterial", scene);
        point.material.diffuseColor = new BABYLON.Color3(0, 0, 1);
        point.position = new BABYLON.Vector3(x, 0.1, z);
        point.rotation.y = zrot;
        point.physicsImpostor = new BABYLON.PhysicsImpostor(point, BABYLON.PhysicsImpostor.BoxImpostor, {
          mass: 0,
          restitution: 0.9
        }, scene);
      }

      function drawParametric(xFn, zFn, start, end, res, scene) {
        for (var t = start; t <= end; t += ((end - start) / res)) {
          drawPoint(xFn(t), zFn(t), -derivAngle(t, xFn, zFn), scene);
        }
      }

      drawParametric(xFn, zFn, 0, 1, 1800, scene);

    
      function tLookup(xFn, zFn, res, x, z) {
        var minT = 0;
        var minDist = Infinity;
        for (var t = 0; t <= 1; t += (1 / res)) {
          var dist = Math.pow(x - xFn(t), 2) + Math.pow(z - zFn(t), 2);
          if (dist < minDist) {
            minDist = dist;
            minT = t;
          }
        }
        return minT;
      }

      function derivAngle(t, xFn, zFn) {
        function derive(f, x) {
          var h = 2.2e-10;
          return (f(x + h) - f(x - h)) / (2 * h);
        }
        return Math.atan2(derive(zFn, t), derive(xFn, t));
      }

      function rampAt(xFn, zFn, t, angle, scene) {
        var ramp = BABYLON.MeshBuilder.CreateBox('ramp', {
          height: 8,
          width: .25,
          depth: 12
        }, scene);
        ramp.material = new BABYLON.StandardMaterial("rampMaterial", scene);
        ramp.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
        ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.BoxImpostor, {
          mass: 0,
          restitution: 0.9
        }, scene);
        ramp.position = new BABYLON.Vector3(xFn(t), 3.2, zFn(t));

        ramp.rotation.z = angle;
        ramp.rotation.y = -derivAngle(t, xFn, zFn);
      }
		//NEW CODE  
		  function wallAt(xFn, zFn, t, offset, scene) {
		var wall = BABYLON.MeshBuilder.CreateBox('wall', {
		height: 8,
		width: .25,
		depth: 12
		}, scene);
		angle = -derivAngle(t, xFn, zFn); 
		wall.material = new BABYLON.StandardMaterial("wallMaterial", scene);
		wall.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
		wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, {
		mass: 0,
		restitution: 0.9
		}, scene);
		wall.position = new BABYLON.Vector3(xFn(t) + (offset * Math.sin(angle)), 4, zFn(t) + (offset * Math.cos(angle)));
		wall.rotation.y = angle + (Math.PI / 2);
		return wall;
		}
	//END NEW CODE
	      engine.runRenderLoop(scene.render.bind(scene));
	      window.addEventListener('resize', engine.resize.bind(engine));
	    }
	    function lost(){
	      window.location.reload();
	      alert("Get well soon!");
	    }
	    function win(){
	        window.location.reload();
	        alert("Congradulations,you win!");
	    }
  </script>
</head>
<body onload="start()">
  <canvas id="renderCanvas"></canvas>

<div id="timer">00:00</div> 

</body>
</html>
